<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Secure Login Service</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /></head><body><div xml:lang="en" class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="idm1"></a>Secure Login Service</h1></div><div><h2 class="subtitle">Operators Guide</h2></div><div><p class="copyright">Copyright © 2024 United Security Providers AG</p></div><div><div class="legalnotice"><a id="idm9"></a><p>
    This document is protected by copyright under the applicable laws and
    international treaties. No part of this document may be reproduced in any
    form and distributed to third parties by any means without prior written
    authorization of United Security Providers AG.
  </p><p>
    DOCUMENTATION IS PROVIDED "AS IS" AND ALL EXPRESSED OR
    IMPLIED REPRESENTATIONS AND WARRANTIES, INCLUDING BUT
    NOT LIMITED TO ANY IMPLIED WARRANTY OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT,
    ARE DISCLAIMED TO THE EXTENT PERMISSIBLE UNDER THE
    APPLICABLE LAWS.
  </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="#_ses_overview">1. SES Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#_introduction">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#_sls_tomcat_instances">1.2. SLS / Tomcat "Instances"</a></span></dt><dt><span class="section"><a href="#_tomcat_configuration">1.3. Tomcat Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_performing_changes">2. Performing Changes</a></span></dt><dd><dl><dt><span class="section"><a href="#_restarting_an_sls">2.1. Restarting an SLS</a></span></dt><dt><span class="section"><a href="#_backup_rollback">2.2. Backup / Rollback</a></span></dt><dt><span class="section"><a href="#_checklist_after_the_change">2.3. Checklist After The Change</a></span></dt></dl></dd><dt><span class="chapter"><a href="#x38738_Heading1Tarsec_3_Health_Check">3. Health Check</a></span></dt><dd><dl><dt><span class="section"><a href="#_regular_web_browser">3.1. Regular Web-Browser</a></span></dt><dt><span class="section"><a href="#x60688_Heading2Tarsec_6_2_Commandline_Browser">3.2. Commandline-Browser</a></span></dt><dt><span class="section"><a href="#_wget">3.3. WGET</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_monitoring_the_sls">4. Monitoring The SLS</a></span></dt><dd><dl><dt><span class="section"><a href="#_introduction_2">4.1. Introduction</a></span></dt><dt><span class="section"><a href="#_monitor_types">4.2. Monitor Types</a></span></dt><dt><span class="section"><a href="#_login_process_example">4.3. Login Process Example</a></span></dt><dt><span class="section"><a href="#_scdid_cookie">4.4. "SCDID" Cookie</a></span></dt><dt><span class="section"><a href="#_login_service_response">4.5. Login Service Response</a></span></dt><dt><span class="section"><a href="#_transparent_monitor_redirect_handling">4.6. Transparent Monitor Redirect Handling</a></span></dt><dt><span class="section"><a href="#_login_service_types">4.7. Login Service Types</a></span></dt><dt><span class="section"><a href="#_application_end_to_end_monitors">4.8. Application end-to-end monitors</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_form_based_authentication">5. FORM-based Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#_example">5.1. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_ntlm_authentication">6. NTLM Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#_java_clients_and_ntlm">6.1. Java Clients and NTLM</a></span></dt><dt><span class="section"><a href="#_login_credentials">6.2. Login Credentials</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_logging_and_debugging">7. Logging And Debugging</a></span></dt><dd><dl><dt><span class="section"><a href="#_sls_tomcat_log_files">7.1. SLS / Tomcat Log Files</a></span></dt><dt><span class="section"><a href="#_log_aggregation_correlation">7.2. Log aggregation / correlation</a></span></dt><dt><span class="section"><a href="#x35667_Heading2Tarsec_7_2_Debug_Trace_Logging">7.3. Debug / Trace Logging</a></span></dt><dt><span class="section"><a href="#_error_messages">7.4. Error Messages</a></span></dt><dt><span class="section"><a href="#x10154_Heading2Tarsec_7_4_Performance_Logging">7.5. Performance Logging</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_debugging_troubleshooting">8. Debugging / Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#x46205_Heading2Tarsec_10_1_File_Permissions">8.1. File Permissions</a></span></dt><dt><span class="section"><a href="#x31358_Heading2Tarsec_10_2_No_Dead_Files_in_webapps">8.2. No "Dead Files" in "webapps"</a></span></dt><dt><span class="section"><a href="#_tomcat_temporary_file_issues">8.3. Tomcat Temporary File Issues</a></span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_ses_overview"></a>Chapter 1. SES Overview</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_introduction"></a>1.1. Introduction</h2></div></div></div><p>It is crucial to have a correct understanding of the SES infrastructure as a whole in order to be able to write monitors with correct behaviour. The following picture shows a simple outline of the SES components</p><div class="informalfigure"><div class="mediaobject"><img src="SES-overview.png" alt="SES-overview.png" /></div></div><p>As shown in the picture, the SES infrastructure actually consists of two relevant components:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
"SES (Secure Entry Server), a native reverse proxy, also referred to as "HSP" (for "Http Secure Proxy")
</li><li class="listitem">
"SLS (Secure Login Service), a Java-based authentication service
</li></ul></div><p>The HSP reverse proxy controls the HTTP or HTTPS connection with the client. If the HSP decides that a client needs to authenticate, it will prevent all requests from that client from reaching the application servers, and will instead redirect it to the SLS for authentication.</p><p>The SLS is involved only during the authentication step. It is responsible for displaying the login page and performing the authentication against the authentication backend, such as LDAP, RADIUS etc.</p><p>Therefore, a restart of an SLS instance will only lead to a short (\~ 1 minute) failure of authentication functionality, but it will not have any impact on existing application sessions.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_sls_tomcat_instances"></a>1.2. SLS / Tomcat "Instances"</h2></div></div></div><p>In most cases there will be just one SLS "instance" on a given server. But sometimes there might be more than one, for example one SLS "instance" for a Test-Environment and one for production use, or one for form-based login and a second one for NTLM authentication.</p><p><span class="emphasis"><em>But what is an SLS "instance" anyway?</em></span></p><p>The SLS itself is just a Java web application that needs a servlet container to run it. By default, Apache's Open Source implementation "Tomcat" is the container used to run the SLS application. Tomcat itself is typically installed in a default location in the system, such as</p><pre class="screen">/opt/apache/tomcat-6.0.18</pre><p>This installation directory contains all Tomcat binary files (.jar files with the Java executable code) and base configurations.</p><p>A Tomcat "instance" is basically a copy of that directory tree, but without all the binary files, and with only the configuration files that differ from the defaults. Which HTTP port an instance uses is configured in that instance, for example. A typical Tomcat instance contains these directories:</p><pre class="screen">/instance/
/bin/
/startup.sh
/shutdown.sh
/setenv.sh
/conf/server.xml
/temp
/work
/webapps/sls/...</pre><p>Some of these directories often contain a lot more files, especially the "<code class="literal">bin</code>" directory, but the files mentioned above are the ones really relevant.</p><p>Note that the following two directories both contain only temporary data which can safely be deleted when an SLS is stopped and before it is started again:</p><pre class="screen">/temp
/work</pre><p>But it is of utmost importance that these two directories itself are present at startup time, or the Tomcat start will fail with sometimes unpredictable behaviour.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_tomcat_configuration"></a>1.3. Tomcat Configuration</h2></div></div></div><p>The following Tomcat configuration files are the most important ones for dealing with SLS operation problems:</p><p><span class="strong"><strong><code class="literal">bin/setenv.sh</code></strong></span></p><p>This script, if it exists, is sources automatically by the other scripts. By defining the environment variables "<code class="literal">CATALINA_HOME</code>", it allows to define which Tomcat installation to use as the base for this instance. The variable "<code class="literal">CATALINA_BASE</code>" must contain the absolute path of the instance directory itself, or startup and shutdown will not work.</p><p><span class="strong"><strong><code class="literal">conf/server.xml</code></strong></span></p><p>This file contains a local shutdown listener port, which must be unique within the local system, the HTTP listener port which must correspond to the port configured in the HSP / SRM login location configuration, and the context path under which the SLS web application will be accessible.</p><p>The contents of this file are important also to determine the correct URI path and port for performing a health check as described in <a class="link" href="#x38738_Heading1Tarsec_3_Health_Check" title="Chapter 3. Health Check">"3 Health Check"</a>.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_performing_changes"></a>Chapter 2. Performing Changes</h1></div></div></div><p>If changes are performed for an SLS instance, a few things should be considered and verified in order to be sure that the functionality is not broken:</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_restarting_an_sls"></a>2.1. Restarting an SLS</h2></div></div></div><p>There is no standard script for SLS Tomcat instances. In case of a "standard" Tomcat instance, shutdown and startup are performed using the respective scripts in the "<code class="literal">bin</code>" subdirectory of the SLS instance:</p><pre class="screen">%&gt; bin/shutdown.sh
%&gt; bin/startup.sh</pre><p>If your environment uses different scripts (such as customized init scripts) please refer to your local runbooks for information on how to stop / start / restart SLS instances.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>A simple restart of the SLS instance will start the Tomcat / Java process, but not yet the actual SLS web application. To enforce a start of the SLS application a functionality check should be performed as described in</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_backup_rollback"></a>2.2. Backup / Rollback</h2></div></div></div><p>Before any changes are performed, always make sure that a rollback to the last working state is possible. If all else fails after the change was applied, perform a roll-back and restart the SLS instance.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_checklist_after_the_change"></a>2.3. Checklist After The Change</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Check the file permissions (see <a class="link" href="#x46205_Heading2Tarsec_10_1_File_Permissions" title="8.1. File Permissions">"File Permissions"</a>)
</li><li class="listitem">
Leave no "dead" files/directories in "webapps" (see <a class="link" href="#x31358_Heading2Tarsec_10_2_No_Dead_Files_in_webapps" title="8.2. No &quot;Dead Files&quot; in &quot;webapps&quot;">"No Dead Files in webapps"</a>)
</li><li class="listitem">
Restart the SLS if necessary (see change instructions)
</li><li class="listitem">
If possible, perform a local health check using "elinks" (see <a class="link" href="#x38738_Heading1Tarsec_3_Health_Check" title="Chapter 3. Health Check">"3 Health Check"</a>). If a login page appears (or the corresponding appropriate respond is received), the SLS instance at least started. If a page is returned with a "System Error" message, or a "404" or a similar Tomcat error, there  was a serious problem and the SLS web application did not start correctly. Check the log files to find the cause for the problem (see  for details). Fix them and restart the SLS instance again.
</li><li class="listitem">
If there are problems that cannot be resolved and a rollback must be performed, collect as much information as possible first for further analysis (log files and copies of the faulty configuration)
</li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="x38738_Heading1Tarsec_3_Health_Check"></a>Chapter 3. Health Check</h1></div></div></div><p>If possible, a health / functionality check should be performed after a change was applied to an SLS instance. To do this, the SLS should be contacted using a web browser or some other HTTP client:</p><p><span class="strong"><strong><span class="emphasis"><em>Regular web-browser</em></span></strong></span></p><p>If possible, connect with a regular web browser, just as the actual users will do it.</p><p><span class="strong"><strong><span class="emphasis"><em>Commandline-browser</em></span></strong></span></p><p>If you cannot connect to the SLS through a regular web browser from "outside" (through the reverse proxy), use an local shell-browser like "elinks" or "lynx" and connect to the Tomcat instance locally. This still allows to perform a simple login in most cases.</p><p><span class="strong"><strong><span class="emphasis"><em>WGET</em></span></strong></span></p><p>If no browser is available at all, use a tool like "wget" to at least trigger a start of the SLS web application and check the login page for any error messages.</p><p>Possible levels of a health-check are:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Send a request just to trigger the start of the SLS web application, and then check the log files for errors
</li><li class="listitem">
Check the actual HTML page returned in the response for error messages
</li><li class="listitem">
Perform a login to make sure that the SLS is not only running, but can actually perform its most important functionality. This depends on having valid login credentials, of course.
</li></ol></div><p>Once a request was submitted to the SLS instance, the SLS web application will be started by the Tomcat container. If there are any serious configuration problems, the SLS web application will either not be started at all, resulting in a "404 resource not available" response from Tomcat. Other types of SLS configuration errors may result in a "System Error" response page sent from the SLS. This indicates that the SLS is not ready for operation, even though the application was started. Check the "<code class="literal">exception.log</code>" and/or "<code class="literal">sls.log"</code> files for information on what might be the cause.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_regular_web_browser"></a>3.1. Regular Web-Browser</h2></div></div></div><p>With a regular web-browser, the actual login URL depends completely on the login location configuration in the reverse proxy. Consult the HSP / SRM configuration to find the appropriate URL for the SLS.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="x60688_Heading2Tarsec_6_2_Commandline_Browser"></a>3.2. Commandline-Browser</h2></div></div></div><p>When using a commandline-browser, the local Tomcat HTTP listener port must be used and the context-path as defined in the Tomcat instance. Take a look at this file in the Tomcat / SLS instance:</p><pre class="screen">%&gt; cd &lt;sls-instance-directory&gt;
%&gt; more conf/server.xml</pre><p>An very minimalistic example result would be:</p><pre class="screen">&lt;Server port="4401" shutdown="SHUTDOWN"&gt;
&lt;Service name="Catalina"&gt;
&lt;Connector *port="4490"* maxHttpHeaderSize="48000" /&gt;
&lt;Engine name="Catalina" defaultHost="localhost"&gt;
&lt;Host name="localhost" appBase="webapps" &gt;
&lt;Context *path="/webapp/sls"* docBase="sls" allowLinking="true"/&gt;
&lt;/Host&gt;
&lt;/Engine&gt;
&lt;/Service&gt;
&lt;/Server&gt;</pre><p><span class="emphasis"><em>NOTE: In "real-life" Tomcat setups, there might be a lot more configuration tags in this file, like log-"Valve"s etc. But the extract above contains only the most relevant parts.</em></span></p><p>The interesting bits are the "port" and the context "path" values. For the example above, the command to retrieve the login page with "elinks" would be:</p><pre class="screen">%&gt; elinks http://localhost:_4490/webapp/sls_/auth</pre><p>The "action"-URI "/auth" must be appended to the context path. In case of some "older" SLS installations, the action may also be "login" instead of "auth":</p><pre class="screen">%&gt; elinks http://localhost:_4490/webapp/sls_/login</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_wget"></a>3.3. WGET</h2></div></div></div><p>For a test with WGET, just issue a request to the local SLS Tomcat instance. Follow the descriptions for the commandline-browser in <a class="link" href="#x60688_Heading2Tarsec_6_2_Commandline_Browser" title="3.2. Commandline-Browser">"Commandline-Browser"</a> to find out the listener port and URI path, and then use the appropriate command:</p><pre class="screen">%&gt; wget http://localhost:4490/webapp/sls/auth</pre><p>By default, this will create a local file named "auth" containing the HTML page received in the response. Check the page to see if it's a login form page, and if it contains any error messages.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_monitoring_the_sls"></a>Chapter 4. Monitoring The SLS</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_introduction_2"></a>4.1. Introduction</h2></div></div></div><p>In every modern IT environment it is common practice to check for the availability of important services in regular intervals. This is usually done by use of automated monitoring tools which perform some form of communication with the service in question.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_monitor_types"></a>4.2. Monitor Types</h2></div></div></div><p>There are often two different classes of monitors (independent of the technology used for them):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Application monitors
</li><li class="listitem">
Infrastructure monitors
</li></ul></div><p>While the formers are meant to check for the availability of the actual application, the latter have to monitor components such as the HSP or the SLS (which are of course part of the infrastructure).</p><p>However, since applications protected by the HSP cannot be accessed directly and without an appropriate authentication step (as long as they are not defined as "public" in the HSP configuration), even application monitors need to interact with the Secure Login Service to some degree. At the very least they must be able to perform a login (usually using credentials of some technical test user), in order to get clearance to access the application server.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_login_process_example"></a>4.3. Login Process Example</h2></div></div></div><p>A typical example of this process when trying to access a web application through a browser looks like this:</p><div class="informalfigure"><div class="mediaobject"><img src="monitoring-1.png" alt="monitoring-1.png" /></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_scdid_cookie"></a>4.4. "SCDID" Cookie</h2></div></div></div><p>When a client connects to the SES for the first time during a session, the SES always creates a cookie named "SCDID". This cookie is used only to map the client to back-end connections. It does NOT in any way indicate that the client is authenticated; it is just a handle for mapping connections from the same client. Therefore, any client must be able to support cookies in order to work successfully with the WES infrastructure (which means it must send the cookie back to the SES with all following requests).</p><p>Please note: This cookie is ALWAYS created by the SES (and NOT the SLS), not matter what the target destination of the client's first request was. So, no matter if the client sends a GET request to the application first, or a POST request to the SLS location, the response will always contain a newly created SCDID cookie from the SES.</p><p>Once the SLS signals a successful authentication, the SES re-creates the SCDID cookie.</p><p>If HTTPS is enabled, the cookie usually is named "SCDID_S". The name of the cookie can be changed in the SES configuration.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_login_service_response"></a>4.5. Login Service Response</h2></div></div></div><p>A monitor should ignore most parts of the response of an SLS. For example, it is strictly recommended to avoid parsing any page contents, HTTP response code (302 or 200), HTML titles etc., and basing any success or failure rules on such contents. The reason is that the behaviour of the SLS is always subject to change in future releases, also due to page redesigns within the customer's intra- or Internet site, or changing requirements of the environments etc.</p><p><span class="strong"><strong>Header "SLSStatus"</strong></span></p><p>For this reason, the monitor should look for exact only one attribute of the SLS response, the custom HTTP header "SLSStatus". This response header is set by the SLS for one purpose only: To indicate the authentication status to any non-browser client, independent of all other aspects of the response. So for the monitor the important points are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Does the response contain a header "SLSStatus"? If yes, the response was actually coming from a Login Service. If not, the response was from another component, probably the HSP itself (like a HSP error page).
</li><li class="listitem">
If the "SLSStatus" header contains the value "200", the client was successfully authenticated. In this case, the client can now access the application. If the "SLSStatus" header contains any other value, the login failed.
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_transparent_monitor_redirect_handling"></a>4.6. Transparent Monitor Redirect Handling</h2></div></div></div><p>If the response from the SLS hangs or shows some unusual delays, the problem can be either with the SLS, or with the monitor behaviour / configuration, in certain cases.</p><p>Example scenario:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
"The application server has technical problems, and all responses from the application have a 1 minute delay.
</li><li class="listitem">
"The monitor sends the POST login request to the SLS, expecting an immediate answer. Instead, the login response seems to hang for 1 minute.
</li><li class="listitem">
"The monitor now shows a red flag, thinking that the SLS is hanging, which in this case probably isn't true.
</li></ol></div><p>Since the SLS does not access the application in any way whatsoever, this kind of problem usually points to the monitor's client code following the redirect response from the SLS automatically. So, in the monitor's code (Java, PERL script etc.), there may be just one single line of code for sending the POST request, but in some cases it depends on the arguments or configuration how the client will deal with a redirect response from the SLS. If the client just tries to transparently follow the redirect, it will of course experience the delay from the application server, and in the monitor's report, this will appear like a delay from the login POST.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_login_service_types"></a>4.7. Login Service Types</h2></div></div></div><p>Please note that there are two fundamentally different types of login services:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Form-based logins
</li><li class="listitem">
Transparent (SSO) logins, usually NTLM
</li></ul></div><p>For the first one, any monitoring client just needs to be able to send HTTP POST requests with parameters in order to interact with the login service.</p><p>The other kind of login service requires the monitor to perform proper NTLM (or Kerberos, certificate etc.)  authentication, which is sometimes handled transparently by underlying technologies, such as NTLM-support in Java 5 for Java-based monitors.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_application_end_to_end_monitors"></a>4.8. Application end-to-end monitors</h2></div></div></div><p>An end-to-end ("e2e") application monitor should reduce its SLS handling to the absolute minimum. First of all, it is not the obligation of such a monitor to perform in-depth functionality checks on the SLS.  And in addition, there's always a possibility that the interface or behaviour of the login service might change in future releases; and in such a case, reducing the interaction with the SLS also reduces the risk of needing to adapt/change a monitor for a new SLS release.</p><p>A typical scenario for an e2e monitor could look like this:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Send a POST login request directly to the login location, with the appropriate parameters. Note that if a client sends a POST request directly (with no GET request first), the SES will not perform the cookie check (which means there will be no redirect to the "/cookie-check" location).
</li></ol></div><p><span class="strong"><strong>SCDID Cookie</strong></span></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
In any case the response will contain a "Set-Cookie" header for the "SCDID" cookie. This header was not set by the SLS, but the SES (since this was the first request from the client in this session).
<span class="emphasis"><em>The client must store this cookie and send it with any following request, just like a browser client would. +</em></span>
</li><li class="listitem">
Check if the response for this POST request contains a header named "SLSStatus". If not, the response is not even from the SLS, or there is a severe technical problem. In either case, the login attempt has failed.
</li><li class="listitem">
If there is a HTTP Header "SLSStatus", check its\' numerical value:
If it is "200", the login was successful. From this point on, the monitor can access the application.
If it is "403", access was denied (authentication failed).
If it is "500", there was a technical problem within the SLS.
</li><li class="listitem">
In addition, the monitor can send (after a successful login) a first request to the application and check if the response is the application page. If it is instead a HTTP 302 (Redirect) back to the login page, there is still a problem with the authentication or entry server configuration.
</li></ol></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_form_based_authentication"></a>Chapter 5. FORM-based Authentication</h1></div></div></div><p>For performing an actual authentication against an SLS with FORM-based login, the monitor must send a POST request to the SLS. It is recommended to make attributes like the request URL, parameter names etc. configurable in order to be prepared for any possible future change in the login service.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_example"></a>5.1. Example</h2></div></div></div><p>In this example of the ficticious company "ACME Inc.", their login service had been configured to be available under the URL context</p><pre class="screen">/webapp/sls</pre><p>being the base context of the login service, so that the actual login action would usually be</p><pre class="screen">/webapp/sls/auth</pre><p>So, the whole URL to POST the request to would be:</p><p><code class="literal">http://www.acme.com/webapp/sls/auth</code></p><p>The required request parameters, based on the names of the form fields in the template login JSP included with the SLS delivery:</p><p>Name: userid</p><p>Value: The user's login ID</p><p>Name: password</p><p>Value: The user's login password</p><p>Name: formName</p><p>Value: loginForm</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_ntlm_authentication"></a>Chapter 6. NTLM Authentication</h1></div></div></div><p>The Windows SSO login service uses NTLM to transparently authenticate the user through his web browser, using the Windows login credentials. Any monitor trying to access an application that uses NTLM authentication must support this authentication scheme itself.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
NTLM Information: 
<code class="literal">http://davenport.sourceforge.net/ntlm.html</code>
</li><li class="listitem">
PERL NTLM support: 
<code class="literal">http://drupal.org/node/44718</code>
</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_java_clients_and_ntlm"></a>6.1. Java Clients and NTLM</h2></div></div></div><p>For any Java-based monitor, there are a few relevant things to consider in relation to NTLM authentication:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
NTLM authentication is officially available on all platforms in Sun's "java.net" HTTP classes (since Java 6).
</li></ul></div><p>There are other client-side HTTP implementations which may provide their own level or type of NTLM support:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Jakarta's Commons HTTP Client (open source)
<code class="literal">http://commons.apache.org/httpclient</code>
</li><li class="listitem">
Oakland Software HTTP Client (commercial)
<code class="literal">http://oaklandsoftware.com/product_http/overview.html</code>
</li></ul></div><p>If the technology/API used by the monitor is based on Sun's HTTP implementation in the JDK, the NTLM authentication is basically available for free. All "HttpUnit"-based clients for example (see <code class="literal">http://httpunit.sourceforge.net</code>) can just directly send their requests to the application, since the NTLM authentication is handled transparently by the underlying HTTP implementation. This means that there is no need to send any request to the login service; that all happens "magically" within the HTTP implementation.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_login_credentials"></a>6.2. Login Credentials</h2></div></div></div><p>Please note that, on Windows, the NTLM implementation in Sun's JDK code will always perform a login with the Windows credentials of the current session (that is, the session which the code is running in) first. Only if that login fails will it use the call-back interface</p><pre class="screen">java.net.Authenticator.getPasswordAuthentication()</pre><p>for retrieving the user credentials. By providing a custom Authenticator subclass implementation, specific credentials can be provided for the next login attempt.</p><p>On other platforms like UNIX, the Authenticator interface is used also for the first login attempt.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_logging_and_debugging"></a>Chapter 7. Logging And Debugging</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_sls_tomcat_log_files"></a>7.1. SLS / Tomcat Log Files</h2></div></div></div><p>By default, the SLS creates a number of log files in the subdirectory "logs" of the SLS instance. Some log files are created by the SLS application, and others are created by the Tomcat container.</p><p>SLS log files:</p><p><span class="strong"><strong><code class="literal">audit.log</code></strong></span></p><p>Contains one log entry for each authentication attempt (success / failure) or operations such as password changes etc. Note that in case of a 2- or 3-step-login procedure, this log file still gets only one log record for the whole login process, not one per request.</p><p><span class="strong"><strong><code class="literal">sls.log</code></strong></span></p><p>The SLS debug log file. If debug or trace logging is enabled, this file will contain a lot of information useful to find the source of any problem.</p><p>exception.log - Contains the error logs in case of serious internal errors, and also the corresponding Java stacktrace, if there was one. This is information that can be very useful for the USP 3rd-level support for deeper problem analysis.</p><p><span class="strong"><strong><code class="literal">performance.log</code></strong></span></p><p>Contains one log record per request and allows to locate - to a certain degree - the point where a performance problem lies (see ).</p><p><span class="strong"><strong><code class="literal">catalina.out</code></strong></span></p><p>Contains the "stdout" and "stderr" output of the SLS Java process. In some cases, error information is printed only to this log file (especially if a problem occurred in a 3rd-party component that is not directly part of the USP Java code). So in case of problems, the contents of this file should be collected for 3rd-level support as well.</p><p>Any additional files are depending on the Tomcat configuration as defined in the "conf/server.xml" files. Please consult the Apache Tomcat documentation for more information:</p><p><a class="ulink" href="http://tomcat.apache.org/tomcat-6.0-doc/logging.html" target="_top">http://tomcat.apache.org/tomcat-6.0-doc/logging.html[http://tomcat.apache.org/tomcat-6.0-doc/logging.html</a>]</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_log_aggregation_correlation"></a>7.2. Log aggregation / correlation</h2></div></div></div><p>All requests that pass the SES Secure Entry Server will recieve a so-called "client-correlator" and "request-correlator" header. As the names imply, the client correlator value allows to correlate log entries from different log files to the same client session, and the request correlator allows to do the same for one single request.</p><p>For this reason, all log files created by the SLS application contain a <code class="literal">[CC:&lt;client-correlator]</code>-string and an <code class="literal">[RC:request-correlator]</code> string.</p><p>If there is a complex problem that may involve the reverse proxy as well, collect all logs from the SES log files and the SLS log files for the client session where the problem occurred by grepping the log files for the entries with the corresponding correlators. In case of the SLS alone, this might be useful to extract only the interesting data from the "<code class="literal">sls.log</code>" file.</p><p>A typical example would be:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
A customer says that certain logins are failing for unknown reasons.
</li><li class="listitem">
If debug logging was not yet enabled, enable it and ask the customer to perform the login again in order to collect come data (see "<a class="link" href="#x35667_Heading2Tarsec_7_2_Debug_Trace_Logging" title="7.3. Debug / Trace Logging">Debug / Trace Logging</a>" for information on how to enable debug logging).
</li><li class="listitem">
Ask for the user ID in question and at what time the failed login was performed.
</li><li class="listitem">
Search the "<code class="literal">audit.log</code>" file for some "authentication failed" message for the user and time given by the customer. This is easier in the "<code class="literal">audit</code>" log file because it usually only contains one log entry for a complete authentication procedure.
</li><li class="listitem">
Then copy the "CC:"-value from the "<code class="literal">audit</code>"-log entry and use it with a "<code class="literal">grep</code>"-command to extract the corresponding debug log entries from the "<code class="literal">sls.log</code>" file.
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="x35667_Heading2Tarsec_7_2_Debug_Trace_Logging"></a>7.3. Debug / Trace Logging</h2></div></div></div><p>If there is a problem that can be reproduced, it may help to collect debug information that can be forwarded to 3rd level support if necessary, or just to find the cause for the problem and fix it.</p><p>The so-called "debug" log file is usually named "<code class="literal">sls.log</code>". In production environments, it contains only messages of level INFO or above, so the logging configuration must be changed to activate debug logging.</p><p>The configuration file that must be changed is:</p><pre class="screen">&lt;sls-instance&gt;/webapps/sls/WEB-INF/log4j.xml</pre><p>In it, there are both log "<code class="literal">appender</code>"-tags and "<code class="literal">logger</code>"-tags. To activate maximum debug (or trace) log level, change the value of the "level"-tag of the "<code class="literal">com.usp</code>"-logger to "DEBUG" or "TRACE", for example:</p><pre class="screen">&lt;logger name="com.usp"&gt;
*+              &lt;level value="DEBUG" /&gt;+*
**      &lt;appender-ref ref="SLS_LOG" /&gt;
&lt;appender-ref ref="EXCEPTION_LOG" /&gt;
&lt;/logger&gt;</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">DEBUG</code> produces a lot more information about the internal processes, but still on a maintainable level
</li><li class="listitem">
<code class="literal">TRACE</code> logs basically ever internal method call and exit; this level is usually only useful if the log information must be forwarded to USPs 3rd-level support for deeper analysis.
</li></ul></div><p><span class="emphasis"><em>NOTE: Do NOT change the "Threshold"-values defined in the various "&lt;appender&gt;"-tags. They should always remain unchanged! Only change the "&lt;level&gt;"-value of the "&lt;logger&gt;"-tags!</em></span></p><p><span class="strong"><strong><span class="emphasis"><em>Restart not mandatory</em></span></strong></span></p><p>Log4j automatically re-reads the "<code class="literal">log4j.xml</code>" configuration file after a while, so a restart of the SLS instance is not mandatory. However, note that it can take up to a minute until the configuration  becomes active.</p><p><span class="strong"><strong><span class="emphasis"><em>what is "&lt;category&gt;"?</em></span></strong></span></p><p>In previous Log4j releases (the logging API used by the SLS), the "&lt;+logger&gt;+" tag was named "&lt;+category+&gt;", and the "&lt;+level&gt;+" tag was named "&lt;+priority&gt;+". Since Log4j is still backwards compatible, both can still be used; but it is recommended to replace "&lt;+category&gt;+" with "&lt;+logger&gt;+" and "&lt;+priority&gt;+" with "&lt;+level&gt;+" in older configuration files.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_error_messages"></a>7.4. Error Messages</h2></div></div></div><p>When there is an SLS error, the "<code class="literal">exception.log</code>" and sometimes also the "<code class="literal">sls.log</code>" file get one or more log records on level ERROR, like this example:</p><pre class="screen">2009-03-13 17:36:44,126 [CC:...] [RC:...] - [AUDIT] [*USER_AUTH_FAILED_TECH*] Authentication failed due to a technical problem. User: \'demo\'. Reason: \'Authentication for user \'\'msc\'\' failed, reason: Receive timed out\'</pre><p>This is an example of a RADIUS authentication that failed because the RADIUS server became unavailable, and the connection attempt from the SLS to the RADIUS server timed out.</p><p>The highlighted string <code class="literal">USER_AUTH_FAILED_TECH</code> is the SLS error message ID that identifies this kind of error. All SLS error messages are documented in the separate "<code class="literal">log-messages.pdf</code>" file. Please read that documentation for more information about any given error, its possible causes and what to do.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="x10154_Heading2Tarsec_7_4_Performance_Logging"></a>7.5. Performance Logging</h2></div></div></div><p>There is a performance log file which receives one log entry for each request the SLS processes. It contains measurements of the internal steps that were performed by the SLS, and of the call-outs.</p><p>A typical entry in an LDAP login service might look like this:</p><pre class="screen">2009-03-13 ... - [Request: 505 [do.auth: 449 [ldap: 446] ] [do.success: 56] ]</pre><p>The most interesting part is usually the step referring to the back-end call-out, which is the "[ldap:]"-part in this case. A short run-down of the example and its parts:</p><p><span class="strong"><strong><code class="literal">Request: 505</code></strong></span></p><p>means that the entire request took 505 milliseconds to be processed by the SLS.</p><p><span class="strong"><strong><code class="literal">do.auth: 449</code></strong></span></p><p>means that the "<code class="literal">do.auth</code>"-step (the actual authentication) took 449 milliseconds to complete. This includes both SLS-internal functionality as well as the call-out to the authentication back-end system.</p><p><span class="strong"><strong><code class="literal">ldap: 446</code></strong></span></p><p>means that the actual LDAP processing took 446 milliseconds. Note that this step is nested inside the "<code class="literal">do.auth</code>"-step, because the call-out to the LDAP service is a part of the authentication step. As a result, the log data means that the entire authentication step took 449 milliseconds, but only 3 milliseconds were spent in the SLS internal logic, and 446 milliseconds were spent performing the LDAP call.</p><p><span class="emphasis"><em>This is usually the most important point to check when there are any performance problems. If the call-out takes a long time, the problem is probably related to the back-end system and not the SLS itself.</em></span></p><p><span class="strong"><strong><code class="literal">do.success: 56</code></strong></span></p><p>This is the final step where the SLS creates any login tickets, custom headers, cookies etc. and performs the redirect to the application. Depending on the configuration and on what the SLS has to do in this step, this can also be a more expensive step. For example, if encrypted and signed tickets must be created after a login, the "do.success" step will take considerably longer because encryption is a very CPU-intensive type of operation.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="_debugging_troubleshooting"></a>Chapter 8. Debugging / Troubleshooting</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="x46205_Heading2Tarsec_10_1_File_Permissions"></a>8.1. File Permissions</h2></div></div></div><p>Typical symptom: "System Error" after SLS restart</p><p>A typical source for problems is that changes are performed manually using an account such as "root", but the SLS service running with a more restricted account. If new files or directories are created during the changes, they will belong to "root", and depending on the local system setup, the SLS service user may not be able to read those files.</p><p>Check the local SLS solaris package to see what the correct permissions should be. As a general rule of thumb, make sure that</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the SLS service user has read access to all directories of the Tomcat instance
</li><li class="listitem">
the SLS service user has write access to the the log directory and all log files.
</li></ul></div><p>In most cases missing read-permissions are the cause for problems.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="x31358_Heading2Tarsec_10_2_No_Dead_Files_in_webapps"></a>8.2. No "Dead Files" in "webapps"</h2></div></div></div><p>Typical symptom: Mysterious errors, new functionality missing</p><p>Make sure that the "webapps" directory of the SLS instance contains only the directories it is supposed to contain; usually, this is just one subdirectory with the SLS web application. In some cases there might also be a second web application with "static" files such as images, CSS files etc.</p><p>A typical cause for "dead" web SLS copies in the "webapps" directory are manual backups made before a change was applied. Never leave backup copies of the SLS web application in the "webapps" directory!</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_tomcat_temporary_file_issues"></a>8.3. Tomcat Temporary File Issues</h2></div></div></div><p>Typical symptom: Mysterious errors, new functionality missing</p><p>There are rare cases when a Tomcat instance for some reasons does not update the temporary files in its "<code class="literal">work</code>" subdirectory correctly after changes have been applied. If there are strange problems such as new functionality not being available even though a new software release had been applied, delete the <span class="emphasis"><em>contents</em></span> of the "<code class="literal">work</code>" directory and restart the SLS instance:</p><pre class="screen">%&gt; rm -rf work/Catalina</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Do NOT delete the "<code class="literal">work</code>" directory itself, but all of its contents!</p></div><p>Restart the SLS instance afterwards. It is normal that the first requests will be slower in this case, because Tomcat needs to re-compile all Java Server Pages (JSPs) again.</p></div></div></div></body></html>